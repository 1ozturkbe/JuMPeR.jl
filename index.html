<!DOCTYPE html>
<html>
<head>
  <meta name="author" content="Iain Dunning">
  <meta charset="utf-8">
  <title>JuMPeR</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro:400,700'
        rel='stylesheet' type='text/css'>
  <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/custom.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/hk-pyg.css" rel="stylesheet" type="text/css" media="all">
  <!--<script src="js/jquery-2.0.3.min.js" type="text/javascript"></script>-->
  <!--<script src="js/bootstrap.min.js" type="text/javascript"></script>-->
  <script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="js/list.min.js" type="text/javascript"></script>
</head>
<body>
  <div id="topbar">
    <div class="container">
      <div class="row">
        <ul>
          <li><div id="pkgname">JuMPeR v0.1</div></li>
          <li><a href="https://github.com/IainNZ/JuMPeR.jl">Code</a></li>
          <li><a href="https://github.com/IainNZ/JuMPeR.jl/issues">Issues</a></li>
          <li><a href="#basics">Basics</a></li>
          <li><a href="#oracles">Oracles</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-sm-12">
      <div id="body-content">
<p><img src="logo.svg" alt="JuMPeR Logo" /><br /></p>
<h1 id="about">About</h1>
<p><strong><a href="https://github.com/IainNZ/JuMPeR.jl">JuMPeR</a></strong> is a modeling language for <a href="http://en.wikipedia.org/wiki/Robust_optimization">robust optimization (RO)</a>. It is embedded in the <a href="http://julialang.org/">Julia programming language</a>, and is an extension to the <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a> modeling language. JuMPeR was created by <a href="http://iaindunning.com">Iain Dunning</a>. Some of the goals of JuMPeR are</p>
<ul>
<li>to make it easy to implement RO models,</li>
<li>to make it easy to switch between solution methods, and</li>
<li>to make it easy to try different uncertainty sets (via <a href="#oracles">oracles</a>.)</li>
</ul>
<p>Here is a small example of a robust 0/1 knapsack problem: <br /><span class="math">$$
\begin{alignat}{2}
\max \  &amp; \sum_{i=1}^{n} p_i x_i \\
\text{subject to} \  &amp; \sum_{i=1}^{n} \left( w_i + \hat{w}_i z_i \right) x_i \leq C \forall \mathbf{z} \in U \\
&amp; \mathbf{x} \in \left\{0,1\right\}^n \\
\text{where} \  &amp; U = \left\{ \mathbf{z} \in \left[0,1\right]^n, \sum_{i=1}^n z_i \leq \Gamma \right\}
\end{alignat}
$$</span><br /> which we can write in JuMPeR as</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">using JuMP, JuMPeR
n, C, Γ = <span class="fl">10</span>, <span class="fl">3</span>, <span class="fl">4</span>
p, w = rand(n), rand(n)
σ = <span class="fl">0.2</span> * rand(n) .* w
knap = RobustModel()
@defVar(knap,      x[<span class="fl">1</span>:n], Bin)
@defUnc(knap, <span class="fl">0</span> &lt;= z[<span class="fl">1</span>:n] &lt;= <span class="fl">1</span>)
@setObjective(knap, Max, sum{p[i]*x[i], i=<span class="fl">1</span>:n})
@addConstraint(knap, sum{(w[i]+σ[i]*z[i])*x[i], i=<span class="fl">1</span>:n} &lt;= C)
@addConstraint(knap, sum{z[i], i=<span class="fl">1</span>:n} &lt;= Γ)
solve(knap)</code></pre>
<p>As JuMPeR builds on JuMP, you should be comfortable with the basics of modeling with <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a> before learning JuMPeR.</p>
<h1 id="installation">Installation</h1>
<p>JuMPeR is a registered Julia package, so you can simply install it with</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">Pkg.add(<span class="st">&quot;JuMPeR&quot;</span>)</code></pre>
<p>Note that both JuMP and JuMPeR do not come with a solver - you'll need to install one. You'll need to be a bit careful about making sure an appropriate solver is installed, for example:</p>
<ul>
<li>If we are solving a linear problem with an ellipsoidal uncertainty set, the reformulation will have second-order cone/quadratic constraints. For example, <a href="http://github.com/JuliaOpt/ECOS.jl">ECOS</a> or <a href="http://github.com/JuliaOpt/Gurobi.jl">Gurobi</a> will work, but <a href="http://github.com/JuliaOpt/Clp.jl">Clp</a> will not.</li>
<li>If we use a cutting-plane method to solve a problem with integer variables, the solver needs to support lazy constraints. For example <a href="http://github.com/JuliaOpt/GLPK.jl">GLPK</a> and <a href="http://github.com/JuliaOpt/CPLEX.jl">CPLEX</a> will work, but <a href="http://github.com/JuliaOpt/Cbc.jl">Cbc</a> will not.</li>
</ul>
<p><a id="basics"></a></p>
<h1 id="basics-of-modeling-ro-problems">Basics of Modeling RO Problems</h1>
<p>In this section we'll dive straight into modeling RO problems with the default <em>oracle</em>, and defer discussion of exactly what an oracle is (in the JuMPeR context) until later. You can think of them as a black box that JuMPeR asks how to solve a problem. They can reformulate constraints with uncertain parameters, and approximate them with cutting planes. The default oracle, called <code>GeneralOracle</code>, takes polyhedral and ellipsoidal constraints on the uncertain parameters and will reformulate them using duality or generate cutting planes by solving LPs/SOCPs.</p>
<h2 id="robustmodel">RobustModel</h2>
<p>It all starts with the <code>RobustModel</code>, which is essentially the same as a JuMP <code>Model</code>. Like a <code>Model</code>, it also accepts a <code>solver</code> keyword argument. It can also take an additional <code>cutsolver</code> keyword argument, which the oracle can use for cutting planes.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># Use default solver for the problem class</span>
rm = RobustModel()
<span class="co"># Can also specify the solver</span>
using Gurobi
rm = RobustModel(solver=GurobiSolver())
<span class="co"># That&#39;d produce a lot of output when using</span>
<span class="co"># cutting planes, so we can set a solver just for cuts</span>
rm = RobustModel(   solver=GurobiSolver(MIPGap=<span class="fl">0.01</span>),
                 cutsolver=GurobiSolver(OutputFlag=<span class="fl">0</span>))</code></pre>
<h2 id="uncertain-parameters">Uncertain Parameters</h2>
<p>JuMPeR adds the <code>Uncertain</code> type to allow the user to model <em>uncertain parameters</em>. <code>Uncertain</code>s behave much like JuMP's <code>Variable</code>s - they have bounds and types, and can be combined with numbers, data, and inequalities to make expressions and constraints. They are defined with <code>@defUnc</code>:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">rm = RobustModel()
<span class="co"># Can define single uncertain parameterss</span>
@defUnc(rm, u)
<span class="co"># Can define indexed uncertain parameters too</span>
@defUnc(rm, v[<span class="fl">4</span>:<span class="fl">10</span>,-<span class="fl">2</span>:<span class="fl">2</span>])
<span class="co"># They can have bounds too</span>
@defUnc(rm, <span class="fl">0</span> &lt;= w[i=<span class="fl">1</span>:<span class="fl">10</span>] &lt;= i^<span class="fl">2</span>)
<span class="co"># You can also have types: integer (Int) and binary (Bin)</span>
<span class="co"># Support for these will depend on the oracle. With the default</span>
<span class="co"># oracle, they will only work with cutting plane mode, as</span>
<span class="co"># reformulation is not possible in general for these types.</span>
idxset = [:Apple, :Banana, :Orange]
@defUnc(rm, fruits[idxset], Bin)</code></pre>
<p>There are some minor restrictions on <code>Uncertain</code> to be aware of:</p>
<ul>
<li>You cannot currently have products of uncertain parameters, e.g. <code>u*u</code> is not allowed.</li>
<li>You cannot use uncertain parameters in the objective. If you have an uncertain objective, you should make an auxiliary variable to represent the objective and turn the objective into a contraint (e.g. an epigraph formulation):</li>
</ul>
<p><br /><span class="math">$$
\begin{alignat}{2}
\max_{\mathbf{x} \in X} \min_{\mathbf{c} \in U} &amp; \quad \mathbf{c} \cdot \mathbf{x}
\end{alignat}
$$</span><br /></p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">rm = RobustModel()
@defVar(rm, x[<span class="fl">1</span>:n])
@defUnc(rm, c[<span class="fl">1</span>:n])
<span class="co"># Create auxiliary for the objective</span>
@defVar(rm, t)
<span class="co"># Epigraph form</span>
@setObjective(rm, Max, t)
@addConstraint(rm, t &lt;= sum{c[i]*x[i],i=<span class="fl">1</span>:n})
<span class="co"># ... constraints x in X ...</span>
<span class="co"># ... constraints c in U ...</span>
solve(rm)</code></pre>
<h2 id="expressions-and-constraints">Expressions and Constraints</h2>
<p>In JuMP we have only data and variables, with one type of expression and one type constraint (mostly). In JuMPeR we have three types of expression, each with are corresponding type of constraint:</p>
<ol type="1">
<li>Just data and variables (internally: <code>AffExpr</code>)</li>
<li>Just data and uncertain parameters (internally: <code>UAffExpr</code>)</li>
<li>Just data, uncertain parameters, and variables (internally: <code>FullAffExpr</code>)</li>
</ol>
<p>Type 1 is just like in JuMP - these a deterministic constraints, and are JuMPeR doesn't do anything with them. JuMPeR treats Type 2 constraints as <em>uncertainty set constraints</em> - that is, they partially define the uncertainty set for this problem. They can be used by the oracles to perform reformulations or generate cutting planes. Type 3 constraints are uncertain constraints that must be feasible for all realizations of the uncertain parameters - these are what the oracles are dealing with to solve the problem. Here is an example of each, from the knapsack problem defined above:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">w = rand(n)
σ = <span class="fl">0.2</span> * rand(n) .* w

knap = RobustModel()
@defVar(knap,      x[<span class="fl">1</span>:n], Bin)
@defUnc(knap, <span class="fl">0</span> &lt;= z[<span class="fl">1</span>:n] &lt;= <span class="fl">1</span>)

<span class="co"># Type 1 constraint: only on the variables</span>
<span class="co">#   &quot;must take at least one item&quot;</span>
@addConstraint(knap, sum{x[i], i=<span class="fl">1</span>:n} &gt;= <span class="fl">1</span>)

<span class="co"># Type 2 constraint: only on the uncertain parameters</span>
<span class="co">#   &quot;only Γ parameters can be at their upper bound&quot;</span>
@addConstraint(knap, sum{z[i], i=<span class="fl">1</span>:n} &lt;= Γ)

<span class="co"># Type 3 constraint: both variables and uncertain parameters</span>
<span class="co">#   &quot;the total uncertain weight of items is less than capacity&quot;</span>
@addConstraint(knap, sum{(w[i]+σ[i]*z[i])*x[i], i=<span class="fl">1</span>:n} &lt;= C)</code></pre>
<h4 id="ellipsoidal-constraints">Ellipsoidal Constraints</h4>
<p>JuMP doesn't provide a convenient syntax to express &quot;ellipsoidal constraints&quot;, i.e.</p>
<p><br /><span class="math">$$
\begin{alignat}{2}
\| \mathbf{x} \|_2 &amp; \leq \Gamma
\end{alignat}
$$</span><br /></p>
<p>but ellipsoidal uncertainty sets are popular. We address this by providing <code>addEllipseConstraint</code>. This function takes 3 arguments: a <code>RobustModel</code>, a vector of <code>Uncertain</code>s or affine expressions of them, and a <strong>constant</strong> right-hand-side that the norm of this vector should be less than. For example:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># A trivial ellipse: 5 &lt;= v &lt;= 7</span>
@defUnc(m, v)
addEllipseConstraint(m, [v], <span class="fl">2</span>)

<span class="co"># An sphere centered at (1,2,3,4,5) with a radius</span>
<span class="co"># of 1 in each dimension</span>
@defUnc(m, u[<span class="fl">1</span>:<span class="fl">5</span>])
addEllipseConstraint(m, [(u-i) <span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:<span class="fl">5</span>], <span class="fl">1</span>)

<span class="co"># A more complicated ellipse</span>
@defUnc(m, w[<span class="fl">1</span>:<span class="fl">5</span>])
addEllipseConstraint(m, [<span class="fl">3.0</span>*w[<span class="fl">1</span>]-<span class="fl">5</span>, <span class="fl">1.0</span>*w[<span class="fl">5</span>]-<span class="fl">5</span>, <span class="fl">2.0</span>*w[<span class="fl">4</span>]-<span class="fl">5</span>], <span class="fl">2</span>)</code></pre>
<h2 id="solving">Solving</h2>
<p>By default, JuMPeR will use duality to reformulate the uncertain problem into a deterministic robust counterpart. However there are a couple of options to customize the solve, not to mention any options you provide to the oracle (more on that later).</p>
<ul>
<li>You can signal that you want cuts with the <code>prefer_cuts</code> option.</li>
<li>If the problem is unbounded before any cuts are added, you can automatically add upper and lower bounds to variables that don't have them already using <code>add_box</code>.</li>
<li>You can get a summary report of how the model was solved and how long the different solve components took by setting the <code>report</code> option.</li>
</ul>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">solve(rm)  <span class="co"># Will use default, which is reformulation</span>
solve(rm, prefer_cuts=true)  <span class="co"># Use cuts if possible</span>
solve(rm, report=true)       <span class="co"># Get some information about the</span>
                             <span class="co"># solution process at the end</span>
solve(rm, add_box=<span class="fl">1e3</span>)       <span class="co"># Provide an upper and lower bound of</span>
                             <span class="co"># 1e3 (or whatever) for all variables</span>
                             <span class="co"># that don&#39;t otherwise have them.</span></code></pre>
<p>Note that the solution methods available depends on the chosen oracle's capabilities. The default oracle supports both, but some uncertainty sets may only support one or the other.</p>
<p><a id="oracles"></a></p>
<h1 id="oracles">Oracles</h1>
<p>JuMPeR's design is focussed around <em>oracles</em>. Oracles are responsible for taking RO problems, or parts of them, and transforming them into something solveable. That could be reformulating uncertain constraints into deterministic constraints, it could be generating cutting-planes, or something else entirely. Oracles are also intimately connected to uncertainty sets - for example, we can provide data to an oracle from which it can generate cutting-planes - an uncertainty set never needs to explictly constructed. Finally oracles are interchangeable - you can obtain oracles from others or create your own to allow others to explore the performance of different sets and implementations.</p>
<p>In this section we will describe how to use oracles other than the default oracle, how to make an oracle, and some design considerations for oracles.</p>
<h2 id="using-oracles">Using oracles</h2>
<p>JuMPeR currently comes with three oracles:</p>
<ul>
<li><code>GeneralOracle</code>, the default oracle. It takes an explicit polyhedral/ellipsoidal representation of the uncertainty set and can generate a reformulation or use cutting-planes.</li>
<li><code>GeneralGraphOracle</code>, a variation on <code>GeneralOracle</code>. This oracle attempts to discover if the uncertain parameters actually belong to seperate, disjunct uncertainty sets. This allows it to generate smaller reformulations, and a seperator cut generator for each set if using cutting-planes.</li>
<li><code>BertSimOracle</code>, implements the uncertainty set described in the 2004 paper <em>The Price of Robustness</em> by Bertsimas and Sim. Will generate cutting-planes efficiently using sorting instead of solving an LP. The <code>GeneralOracle</code> should be used if a reformulation is desired.</li>
</ul>
<p>To set the oracle for all constraints, use the <code>setDefaultOracle!</code> command, e.g.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">n           = <span class="fl">3</span>
weight_low  = [<span class="fl">1.0</span>, <span class="fl">3.0</span>, <span class="fl">2.0</span>]
weight_high = [<span class="fl">3.0</span>, <span class="fl">9.0</span>, <span class="fl">6.0</span>]
values      = [<span class="fl">5.0</span>, <span class="fl">6.0</span>, <span class="fl">4.0</span>]

<span class="co"># Create the model...</span>
m = RobustModel()
<span class="co"># ... and set all constraints to use the Bertsimas-Sim set</span>
setDefaultOracle!(m, BertSimOracle(<span class="fl">1</span>))

<span class="co"># Setup our problem</span>
@defVar(m, x[<span class="fl">1</span>:n], Bin)
@defUnc(m, weight_low[i] &lt;= u[i=<span class="fl">1</span>:n] &lt;= weight_high[i])
@setObjective(m, Max, sum{values[i] * x[i], i=<span class="fl">1</span>:n})

<span class="co"># Notice we haven&#39;t provided an explicit uncertainty set,</span>
<span class="co"># apart from the ranges on the uncertain values?</span>
<span class="co"># The BertSimOracle looks at the range, and treats the</span>
<span class="co"># nominal value for each uncertain parameter as the</span>
<span class="co"># midpoint of the range. The parameter we passed is the</span>
<span class="co"># number of uncertain parameters that can deviate from</span>
<span class="co"># this nominal value. In other words:</span>
<span class="co">#   |u - 4|/1  +  |u - 6|/3  +  |u - 4|/2  &lt;=  1</span>
<span class="co">#   |u - 4|/1  &lt;=  1</span>
<span class="co">#   |u - 6|/3  &lt;=  1</span>
<span class="co">#   |u - 4|/2  &lt;=  1</span>
@addConstraint(m, sum{u[i]*x[i], i=<span class="fl">1</span>:n} &lt;= <span class="fl">8</span>)

solve(m, prefer_cuts=true)</code></pre>
<h2 id="making-an-oracle">Making an oracle</h2>
<p>To make an oracle, we first need to understand what happens when you call <code>solve</code> on a <code>RobustModel</code>:</p>
<ol type="1">
<li>A new JuMP <code>Model</code>, referred to as the <em>master</em>, is created with the same variables as the original <code>RobustModel</code> and with all the deterministic constraints.</li>
<li>For each constraint, <code>registerConstraint</code> is called for the oracle associated with that constraint. Any constraints that don't have a oracle explicitly provided use the default.</li>
<li><code>setup</code> is called for each oracle, giving them time to do any general setup shared across constraints. For example, it may take the dual of the uncertainty set in order to more efficiently reformulate multiple constraints.</li>
<li>Each oracle is then given a chance to reformulate its constraints (<code>generateReform</code>). It will return the number of constraints reformulated (which may be zero).</li>
<li>Start solving</li>
</ol>
<ul>
<li>If the problem is continuous, the master problem will be solved.</li>
<li>If the problem has integer variables, the MIP solver will be started.</li>
</ul>
<ol start="6" type="1">
<li>Oracles get a chance to generate cutting-planes.</li>
</ol>
<ul>
<li>If the problem is continuous, the cutting-planes are added to the master problem and the master problem is resolved. If no new constraints are added, we terminate the solve.</li>
<li>If the problem has integer variables, the cutting-planes are added as lazy constraints only at integer solutions. The solve terminates when the MIP solver finds an optimal integer solution and no new constraints are added.</li>
</ul>
<p>We can now specific how to make an oracle. An oracle should be a Julia type that is a subtype of <code>AbstractOracle</code>, i.e.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="kw">type</span> MyNewOracle &lt;: JuMPeR.AbstractOracle
    some_internal_state
<span class="kw">end</span></code></pre>
<p>The oracle must implement four methods, regardless of its functionality (defined in <code>src/oracle.jl</code>)</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># registerConstraint</span>
<span class="co"># Notifies the oracle that it is responsible for this constraint, and </span>
<span class="co"># passes any preferences provided via the solveRobust() command.</span>
<span class="kw">function</span> registerConstraint(ab::AbstractOracle, rm::Model, ind::<span class="dt">Int</span>, prefs)

<span class="co"># setup</span>
<span class="co"># Gives oracle time to do any setup it needs to do. Called after all</span>
<span class="co"># constraints have been registered. Examples of work that could be done here</span>
<span class="co"># include transforming the uncertainty set and generating a cutting plane</span>
<span class="co"># model. Will NOT be called multiple times.</span>
<span class="kw">function</span> setup(ab::AbstractOracle, rm::Model, prefs)

<span class="co"># generateReform</span>
<span class="co"># Called before the main loop, adds anything it wants to the model. Returns</span>
<span class="co"># number of constraints reformulated. If reformulation not supported or </span>
<span class="co"># desired, simply return 0</span>
<span class="kw">function</span> generateReform(ab::AbstractOracle, master::Model, rm::Model, inds::<span class="dt">Vector</span>{<span class="dt">Int</span>})

<span class="co"># generateCut</span>
<span class="co"># Called in the main loop every iteration/every time an integer solution is</span>
<span class="co"># found. Returns a vector of constraints which are added to the problem by</span>
<span class="co"># the main solve loop. Return an empty list if there are no constraints to add.</span>
<span class="co"># The optional &quot;active&quot; argument will be called if the user wants to know</span>
<span class="co"># the active scenarios at optimality. This is still experimental!</span>
generateCut(ab::AbstractOracle, master::Model, rm::Model, inds::<span class="dt">Vector</span>{<span class="dt">Int</span>}, active=false)</code></pre>
<h2 id="oracle-design-advice">Oracle design advice</h2>
<p>Stay tuned, watch this space, etc.</p>
        <hr>
      </div>
      </div>
    </div>

  <footer class="col-sm-12">
    <p class="muted">File created Wed Feb 18 00:18:53 EST 2015 with
    <a href="https://github.com/dcjones/Judo.jl">Judo</a>.</p>
  </footer>

  </div>
</body>
</html>

