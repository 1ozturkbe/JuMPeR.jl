<!DOCTYPE html>
<html>
<head>
  <meta name="author" content="Iain Dunning">
  <meta charset="utf-8">
  <title>JuMPeR</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro:400,700'
        rel='stylesheet' type='text/css'>
  <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/custom.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/hk-pyg.css" rel="stylesheet" type="text/css" media="all">
  <!--<script src="js/jquery-2.0.3.min.js" type="text/javascript"></script>-->
  <!--<script src="js/bootstrap.min.js" type="text/javascript"></script>-->
  <script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="js/list.min.js" type="text/javascript"></script>
</head>
<body>
  <div id="topbar">
    <div class="container">
      <div class="row">
        <ul>
          <li><div id="pkgname">JuMPeR v0.1</div></li>
          <li><a href="https://github.com/IainNZ/JuMPeR.jl">Code</a></li>
          <li><a href="https://github.com/IainNZ/JuMPeR.jl/issues">Issues</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-sm-12">
      <div id="body-content">
<p><img src="logo.svg" alt="JuMPeR Logo" /><br /></p>
<h1 id="introduction">Introduction</h1>
<p><strong><a href="https://github.com/IainNZ/JuMPeR.jl">JuMPeR</a></strong> is a modeling language for <strong><a href="http://en.wikipedia.org/wiki/Robust_optimization">robust optimization (RO)</a></strong>. It is embedded in the <strong><a href="http://julialang.org/">Julia programming language</a></strong>, and is an extension to the <strong><a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a></strong> modeling language. The goals of JuMPeR are</p>
<ul>
<li>to make it easy to implement RO models,</li>
<li>to make it easy to switch between solution methods, and</li>
<li>to make it easy to try different uncertainty sets (via <strong>oracles</strong>.)</li>
</ul>
<p>Here is a small example of a robust 0/1 knapsack problem: <br /><span class="math">$$
\begin{alignat}{2}
\max \  &amp; \sum_{i=1}^{n} p_i x_i \\
\text{subject to} \  &amp; \sum_{i=1}^{n} \left( w_i + \hat{w}_i z_i \right) x_i \leq C \forall \mathbf{z} \in U \\
&amp; \mathbf{x} \in \left\{0,1\right\}^n \\
\text{where} \  &amp; U = \left\{ \mathbf{z} \in \left[0,1\right]^n, \sum_{i=1}^n z_i \leq \Gamma \right\}
\end{alignat}
$$</span><br /> which we can write in JuMPeR as</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">using JuMP, JuMPeR
n, C = <span class="fl">10</span>, <span class="fl">3</span>
p, w = rand(n), rand(n)
σ = <span class="fl">0.2</span> * rand(n) .* w
knap = RobustModel()
@defVar(knap,      x[<span class="fl">1</span>:n], Bin)
@defUnc(knap, <span class="fl">0</span> &lt;= z[<span class="fl">1</span>:n] &lt;= <span class="fl">1</span>)
@setObjective(knap, Max, sum{p[i]*x[i], i=<span class="fl">1</span>:n})
@addConstraint(knap, sum{(w[i]+σ[i]*z[i])*x[i], i=<span class="fl">1</span>:n} &lt;= C)
solve(knap)</code></pre>
<p>As JuMPeR builds on JuMP, you should be comfortable with the basics of modeling with <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a> before learning JuMPeR.</p>
<h1 id="installation">Installation</h1>
<p>JuMPeR is a registered Julia package, so you can simply install it with</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">Pkg.add(<span class="st">&quot;JuMPeR&quot;</span>)</code></pre>
<p>Note that both JuMP and JuMPeR do not come with a solver - you'll need to install one. You'll need to be a bit careful about making sure an appropriate solver is installed, for example:</p>
<ul>
<li>If we are solving a linear problem with an ellipsoidal uncertainty set, the reformulation will have second-order cone/quadratic constraints. For example, ECOS or Gurobi will work, but Clp will not.</li>
<li>If we use a cutting-plane method to solve a problem with integer variables, the solver needs to support lazy constraints. For example GLPK and CPLEX will work, but Cbc will not.</li>
</ul>
<h1 id="modeling-ro-problems">Modeling RO Problems</h1>
<h2 id="robustmodel">RobustModel</h2>
<p>It all starts with the <code>RobustModel</code>, which is essentially the same as a JuMP <code>Model</code>. Like a <code>Model</code>, it also accepts a <code>solver</code> keyword argument. It can also take an additional <code>cutsolver</code> keyword argument, which the oracle can use for cutting planes.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># Use default solver for the problem class</span>
rm = RobustModel()
<span class="co"># Can also specify the solver</span>
using Gurobi
rm = RobustModel(solver=GurobiSolver())
<span class="co"># That&#39;d produce a lot of output when using</span>
<span class="co"># cutting planes, so we can set a solver just for cuts</span>
rm = RobustModel(   solver=GurobiSolver(MIPGap=<span class="fl">0.01</span>),
                 cutsolver=GurobiSolver(OutputFlag=<span class="fl">0</span>))</code></pre>
        <hr>
      </div>
      </div>
    </div>

  <footer class="col-sm-12">
    <p class="muted">File created Sun Feb 15 01:21:25 EST 2015 with
    <a href="https://github.com/dcjones/Judo.jl">Judo</a>.</p>
  </footer>

  </div>
</body>
</html>

